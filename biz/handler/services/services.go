// Code generated by hertz generator.

package services

import (
	services "GoGateway/biz/model/services"
	"GoGateway/conf"
	serviceDAO "GoGateway/dao/services"
	serviceConsts "GoGateway/pkg/consts/service"
	"GoGateway/pkg/status"
	serviceSVC "GoGateway/svc/services"
	"context"
	"fmt"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"net/http"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// ServiceList .
// @router /service/list [GET]
func ServiceList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req services.ServiceListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(http.StatusBadRequest, status.NewErrorResponse(err.Error()))
		return
	}

	svc := serviceSVC.ServiceInfoSvcLayer{}

	total, serviceList, err := svc.PageList(req.Info, req.PageNum, req.PageSize)
	if err != nil {
		status.ErrToHttpResponse(c, err)
		return
	}

	var respList []*services.ServiceInfoResponse

	for _, s := range serviceList {
		serviceDetail, err := svc.ServiceDetail(&s)
		if err != nil {
			status.ErrToHttpResponse(c, err)
			return
		}

		serviceAddr := "unknown"

		clusterInfo := conf.GetConfig().Cluster

		switch serviceDetail.Info.LoadType {
		case serviceConsts.ServiceLoadTypeHTTP:
			port := clusterInfo.Port
			if serviceDetail.Http.NeedHttps == 1 {
				port = clusterInfo.SSLPort
			}
			if serviceDetail.Http.RuleType == serviceConsts.HTTPRuleTypePrefixURL {
				serviceAddr = fmt.Sprintf("%s:%d.%s", clusterInfo.IP, port, serviceDetail.Http.Rule)
			} else if serviceDetail.Http.RuleType == serviceConsts.HTTPRuleTypeDomain {
				serviceAddr = serviceDetail.Http.Rule
			}
		case serviceConsts.ServiceLoadTypeGRPC:
			serviceAddr = fmt.Sprintf("%s:%d", clusterInfo.IP, serviceDetail.Grpc.Port)
		case serviceConsts.ServiceLoadTypeTCP:
			serviceAddr = fmt.Sprintf("%s:%d", clusterInfo.IP, serviceDetail.Tcp.Port)
		default:
			hlog.Errorf("service type not support: %v", serviceDetail.Info.LoadType)
			c.JSON(http.StatusInternalServerError, "服务器内部错误")
		}

		ipList := strings.Split(serviceDetail.LoadBalance.IpList, ",")

		respList = append(respList, s.ToHttpResponse(serviceAddr, len(ipList)))
	}

	resp := services.ServiceListResponse{
		Total: total,
		Data:  respList,
	}

	c.JSON(consts.StatusOK, resp)
}

// ServiceDelete .
// @router /service/delete [DELETE]
func ServiceDelete(ctx context.Context, c *app.RequestContext) {
	var err error
	var req services.ServiceDeleteRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(http.StatusBadRequest, status.NewErrorResponse(err.Error()))
		return
	}

	repository := serviceDAO.ServiceInfoRepository{}

	err = repository.Delete(uint(req.ID))
	if err != nil {
		status.ErrToHttpResponse(c, err)
		return
	}

	resp := new(services.MessageResponse)

	resp.Message = "删除成功"

	c.JSON(consts.StatusOK, resp)
}

// ServiceAddHTTP .
// @router /service/add/http [POST]
func ServiceAddHTTP(ctx context.Context, c *app.RequestContext) {
	var err error
	var req services.ServiceAddHTTPRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(http.StatusBadRequest, status.NewErrorResponse(err.Error()))
		return
	}

	// validate input

	infoRepo := serviceDAO.ServiceInfoRepository{}
	if _, err = infoRepo.Find(&serviceDAO.ServiceInfo{ServiceName: req.ServiceName}); err == nil {
		c.JSON(http.StatusConflict, status.NewErrorResponse("服务名已被占用"))
		return
	}

	httpRepo := serviceDAO.ServiceHttpRuleRepository{}
	if _, err = httpRepo.Find(&serviceDAO.ServiceHttpRule{RuleType: int(req.RuleType), Rule: req.Rule}); err == nil {
		c.JSON(http.StatusConflict, status.NewErrorResponse("服务接入前缀或域名已存在"))
		return
	}

	if len(strings.Split(req.IpList, "\n")) != len(strings.Split(req.WeightList, "\n")) {
		c.JSON(http.StatusBadRequest, status.NewErrorResponse("ip与权重列表不等"))
		return
	}

	svc := serviceSVC.ServiceInfoSvcLayer{}

	if err := svc.NewHTTPService(req); err != nil {
		status.ErrToHttpResponse(c, err)
		return
	}

	resp := new(services.MessageResponse)

	resp.Message = "HTTP服务创建成功"

	c.JSON(consts.StatusOK, resp)
}
